#!/usr/bin/env bash
# Grov CLI: worktrees, workspace symlink, and .grov/scripts.
#
# Install: run ./install from this repo (or ln -sf path/to/grov/grov ~/bin/grov).
# Usage: grov <command> [args...]
#   init                    convert current git repo to dev layout (bare at .grov/repo.git)
#   checkout [-b] <branch>  ensure worktree exists, point workspace at it
#   switch <branch>         point workspace at existing worktree only
#   add [-b] <branch>      create worktree only (no link change)
#   status                  list worktrees and linked branch with git state
#   remove <branch>         remove a worktree
#   root                    print grov project root
#   branch                  print active (linked) branch name
#   branches                list worktree branch names
#   path [branch]           print active workspace path, or path to branch worktree
#   scripts                 list custom scripts in .grov/scripts
#   <script>                run .grov/scripts/<script> if present

set -e
LINK_NAME="workspace"
BRANCHES_DIR_NAME="branches"
BARE_REPO=".grov/repo.git"

get_primary_dir() {
  local root=$1
  cat "$root/.grov/primary-dir" 2>/dev/null || echo "master"
}

find_dev_root() {
  local d="$PWD"
  while [[ -n "$d" && "$d" != "/" ]]; do
    [[ -e "$d/.grov" ]] && echo "$d" && return 0
    d="${d%/*}"
  done
  [[ -n "$GROV_ROOT" && -e "$GROV_ROOT/.grov" ]] && echo "$GROV_ROOT" && return 0
  local script_path
  script_path=$(readlink -f "$0" 2>/dev/null || true)
  if [[ -n "$script_path" ]]; then
    d=$(dirname "$script_path")
    d=$(dirname "$d")
    [[ -e "$d/.grov" ]] && echo "$d" && return 0
  fi
  return 1
}

ensure_workspace() {
  local root=$1
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  if [[ -L "$link_path" ]]; then return 0; fi
  local branches_dir="$root/$BRANCHES_DIR_NAME"
  [[ ! -d "$branches_dir" ]] && return 1
  local first
  first=$(ls -1d "$branches_dir"/*/ 2>/dev/null | head -1)
  [[ -z "$first" ]] && return 1
  ln -sfn "$BRANCHES_DIR_NAME/$(basename "$first")" "$link_path"
}

get_linked_branch() {
  local root=$1
  ensure_workspace "$root" || true
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  if [[ ! -L "$link_path" ]]; then echo ""; return 1; fi
  local target
  target=$(readlink -f "$link_path")
  [[ -z "$target" ]] && echo "" && return 1
  basename "$target"
}

get_current_branch_from_cwd() {
  local root=$1
  local branches="$root/$BRANCHES_DIR_NAME"
  if [[ "$PWD" != "$branches"/* ]]; then
    echo ""; return 1
  fi
  local rest="${PWD#$branches/}"
  echo "${rest%%/*}"
}

get_worktree_path() {
  echo "$1/$BRANCHES_DIR_NAME/$2"
}

list_branch_dirs() {
  local root=$1
  local dir="$root/$BRANCHES_DIR_NAME"
  [[ ! -d "$dir" ]] && return 0
  local d
  for d in "$dir"/*/; do
    [[ -d "$d" ]] && basename "$d"
  done | sort
}

usage() {
  echo "Usage: grov <init|checkout|switch|add|status|remove|root|branch|branches|path|restore|scripts> [args...]"
  echo "  init                    convert current git repo to grov layout"
  echo "  restore                 convert grov project back to normal git repo (linked branch at root)"
  echo "  checkout [-b] <branch>  ensure worktree exists, point workspace at it"
  echo "  switch <branch>         point workspace at existing worktree only"
  echo "  add [-b] <branch>      create worktree only (no link change)"
  echo "  status                  list worktrees and linked branch with git state"
  echo "  remove <branch>         remove a worktree"
  echo "  root                    print grov project root"
  echo "  branch                  print active (linked) branch name"
  echo "  branches                list worktree branch names"
  echo "  path [branch]           print active workspace path, or path to branch worktree"
  echo "  scripts                 list custom scripts in .grov/scripts"
  echo "  <name>                  run .grov/scripts/<name> if present"
  exit 1
}

has_bare() { [[ -d "$1/$BARE_REPO" ]]; }

ensure_worktree() {
  local root=$1
  local create_branch=$2
  local branch=$3
  local wt_path
  wt_path=$(cd "$root" && pwd)/$BRANCHES_DIR_NAME/$branch
  local bare="$root/$BARE_REPO"
  if has_bare "$root"; then
    if [[ ! -d "$wt_path" ]]; then
      if [[ "$create_branch" == true ]]; then
        local src
        src=$(get_linked_branch "$root")
        [[ -z "$src" ]] && src="HEAD"
        git --git-dir="$bare" worktree add -b "$branch" "$wt_path" "$src"
        echo "Created branch '$branch' and worktree at $wt_path"
      else
        if ! git --git-dir="$bare" rev-parse --verify "$branch" &>/dev/null; then
          echo "Error: Branch '$branch' does not exist. Use: grov checkout -b <branch>" >&2
          exit 1
        fi
        git --git-dir="$bare" worktree add "$wt_path" "$branch"
        echo "Created worktree at $wt_path"
      fi
    fi
  else
    local primary_dir
    primary_dir=$(get_primary_dir "$root")
    local repo="$root/$BRANCHES_DIR_NAME/$primary_dir"
    if [[ ! -d "$repo/.git" ]]; then
      echo "Error: No .grov/repo.git and no primary worktree at $repo. Run grov init first." >&2
      exit 1
    fi
    if [[ -d "$wt_path" ]]; then
      :
    elif [[ "$create_branch" == true ]]; then
      local src
      src=$(get_linked_branch "$root")
      [[ -z "$src" ]] && echo "Error: workspace not linked; cannot use -b." >&2 && exit 1
      git -C "$repo" worktree add -b "$branch" "$wt_path" "$src"
      echo "Created branch '$branch' from '$src' and worktree at $wt_path"
    else
      if ! git -C "$repo" rev-parse --verify "$branch" &>/dev/null; then
        echo "Error: Branch '$branch' does not exist. Use: grov checkout -b <branch>" >&2
        exit 1
      fi
      git -C "$repo" worktree add "$wt_path" "$branch"
      echo "Created worktree at $wt_path"
    fi
  fi
}

cmd_init() {
  local root
  root=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo "Error: Not inside a git repository. Run grov init from a repo root." >&2
    exit 1
  }
  cd "$root" || exit 1
  if [[ -e "$root/.grov" ]]; then
    echo "Error: Already a grov project (.grov exists)." >&2
    exit 1
  fi
  local branch
  branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || branch="rescue"
  [[ "$branch" == "HEAD" || -z "$branch" ]] && branch="rescue"
  local branch_dir="${branch//[^a-zA-Z0-9._-]/_}"
  mkdir -p .grov/scripts .grov/old-checkout
  echo "$branch_dir" > .grov/primary-dir
  echo "$branch" > .grov/primary-branch
  # Move untracked out first so we don't overwrite them when creating worktree at branches/
  (cd "$root" && git ls-files --others --exclude-standard) | while IFS= read -r f; do
    [[ -n "$f" && -e "$root/$f" ]] || continue
    mkdir -p "$root/.grov/old-checkout/$(dirname "$f")"
    mv "$root/$f" "$root/.grov/old-checkout/$f"
  done
  git init --bare "$BARE_REPO"
  (cd "$root" && git remote add _dev_bare "$(pwd)/$BARE_REPO" && git push _dev_bare --all && git push _dev_bare --tags 2>/dev/null; git remote remove _dev_bare 2>/dev/null)
  # Copy remotes from original repo into bare so fetch/push still work
  while IFS= read -r name; do
    [[ -z "$name" ]] && continue
    url=$(git -C "$root" config --get "remote.$name.url" 2>/dev/null)
    [[ -z "$url" ]] && continue
    git --git-dir="$root/$BARE_REPO" remote add "$name" "$url" 2>/dev/null || true
    git -C "$root" config --get-all "remote.$name.fetch" 2>/dev/null | while IFS= read -r refspec; do
      [[ -n "$refspec" ]] && git --git-dir="$root/$BARE_REPO" config --add "remote.$name.fetch" "$refspec"
    done
  done < <(git -C "$root" remote 2>/dev/null)
  mkdir -p "$BRANCHES_DIR_NAME"
  local wt_path
  wt_path=$(cd "$root" && pwd)/$BRANCHES_DIR_NAME/$branch_dir
  if ! git --git-dir="$root/$BARE_REPO" rev-parse --verify "$branch" &>/dev/null; then
    echo "Error: Branch '$branch' not in bare repo (push may have failed)." >&2
    exit 1
  fi
  git --git-dir="$root/$BARE_REPO" worktree add "$wt_path" "$branch"
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  ln -sfn "$BRANCHES_DIR_NAME/$branch_dir" "$link_path"
  find "$root" -mindepth 1 -maxdepth 1 ! -name .grov ! -name "$BRANCHES_DIR_NAME" ! -name "$LINK_NAME" ! -name .git -exec rm -rf {} +
  rm -rf "$root/.git"
  echo "Untracked files from previous working tree. Refs in .grov/repo.git; worktree at branches/$branch_dir" > "$root/.grov/old-checkout/README.txt"
  echo "Initialized. workspace -> branches/$branch_dir. Untracked files in .grov/old-checkout."
}

cmd_root() {
  echo "$1"
}

cmd_branch() {
  local root=$1
  ensure_workspace "$root" || { echo "Error: No workspace (no branches?)." >&2; exit 1; }
  get_linked_branch "$root"
}

cmd_branches() {
  list_branch_dirs "$1"
}

cmd_path() {
  local root=$1
  shift
  local branch="${1:-}"
  if [[ -n "$branch" ]]; then
    local wt_path
    wt_path=$(get_worktree_path "$root" "$branch")
    wt_path=$(readlink -f "$wt_path" 2>/dev/null || true)
    [[ -z "$wt_path" || ! -d "$wt_path" ]] && wt_path="$root/$BRANCHES_DIR_NAME/$branch"
    if [[ ! -d "$wt_path" ]]; then
      echo "Error: Worktree does not exist: $wt_path" >&2
      exit 1
    fi
    echo "$wt_path"
  else
    ensure_workspace "$root" || { echo "Error: No workspace (no branches?)." >&2; exit 1; }
    local link_path
    link_path=$(cd "$root" && pwd)/$LINK_NAME
    readlink -f "$link_path"
  fi
}

cmd_checkout() {
  local root=$1
  shift
  local branch="$1"
  [[ "$1" == "-b" ]] && branch="$2"
  [[ -z "$branch" ]] && echo "Usage: grov checkout [-b] <branch>" >&2 && exit 1
  cmd_add "$root" "$@"
  cmd_switch "$root" "$branch"
}

cmd_switch() {
  local root=$1
  shift
  local branch="$1"
  [[ -z "$branch" ]] && echo "Usage: grov switch <branch>" >&2 && exit 1
  local wt_path
  wt_path=$(cd "$root" && pwd)/$BRANCHES_DIR_NAME/$branch
  if [[ ! -d "$wt_path" ]]; then
    echo "Error: Worktree does not exist. Use: grov checkout <branch> or grov add <branch>" >&2
    exit 1
  fi
  ensure_workspace "$root" || true
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  ln -sfn "$BRANCHES_DIR_NAME/$branch" "$link_path"
}

cmd_add() {
  local root=$1
  shift
  local create_branch=false
  if [[ "$1" == "-b" ]]; then create_branch=true; shift; fi
  local branch="$1"
  [[ -z "$branch" ]] && echo "Usage: grov add [-b] <branch>" >&2 && exit 1
  ensure_worktree "$root" "$create_branch" "$branch"
}

cmd_scripts() {
  local root=$1
  local dir="$root/.grov/scripts"
  [[ ! -d "$dir" ]] && return 0
  local f
  for f in "$dir"/*; do
    [[ -f "$f" && -x "$f" ]] && basename "$f"
  done | sort
}

cmd_remove() {
  local root=$1
  shift
  local branch="$1"
  [[ -z "$branch" ]] && echo "Usage: grov remove <branch>" >&2 && exit 1
  local wt_path
  wt_path=$(cd "$root" && pwd)/$BRANCHES_DIR_NAME/$branch
  if [[ ! -d "$wt_path" ]]; then
    echo "Error: No worktree at $wt_path" >&2
    exit 1
  fi
  if has_bare "$root"; then
    git --git-dir="$root/$BARE_REPO" worktree remove "$wt_path"
  else
    local primary_dir
    primary_dir=$(get_primary_dir "$root")
    if [[ "$branch" == "$primary_dir" ]]; then
      echo "Error: Cannot remove the primary worktree ($primary_dir)." >&2
      exit 1
    fi
    git -C "$root/$BRANCHES_DIR_NAME/$primary_dir" worktree remove "$wt_path"
  fi
  echo "Removed worktree: $branch"
}

cmd_status() {
  local root=$1
  ensure_workspace "$root" || true
  local link_path="$root/$LINK_NAME"
  local linked=""
  if [[ -L "$link_path" ]]; then
    linked=$(basename "$(readlink "$link_path")")
  fi
  echo "Linked: ${linked:-none}"
  echo ""

  local branch
  while IFS= read -r branch; do
    [[ -z "$branch" ]] && continue
    local wt_path
    wt_path=$(get_worktree_path "$root" "$branch")
    [[ ! -d "$wt_path" ]] && continue

    local marker=""
    [[ "$branch" == "$linked" ]] && marker=" (linked)"

    local state=""
    if git -C "$wt_path" rev-parse --is-inside-work-tree &>/dev/null; then
      if [[ -n $(git -C "$wt_path" status -s 2>/dev/null) ]]; then
        state="uncommitted"
      else
        local ahead behind
        ahead=$(git -C "$wt_path" rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        behind=$(git -C "$wt_path" rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
        if [[ "$ahead" != "0" || "$behind" != "0" ]]; then
          state="ahead $ahead, behind $behind"
        else
          state="clean"
        fi
      fi
    else
      state="?"
    fi
    echo "  $branch$marker  $state"
  done < <(list_branch_dirs "$root")
}

cmd_restore() {
  local root=$1
  if [[ ! -d "$root/$BARE_REPO" ]]; then
    echo "Error: Not a grov project (no $BARE_REPO)." >&2
    exit 1
  fi
  ensure_workspace "$root" || { echo "Error: No workspace linked." >&2; exit 1; }
  local linked_dir
  linked_dir=$(get_linked_branch "$root")
  [[ -z "$linked_dir" ]] && { echo "Error: Could not get linked branch." >&2; exit 1; }
  local linked_wt="$root/$BRANCHES_DIR_NAME/$linked_dir"
  [[ ! -d "$linked_wt" ]] && { echo "Error: Worktree $linked_wt not found." >&2; exit 1; }
  local primary_branch
  primary_branch=$(cat "$root/.grov/primary-branch" 2>/dev/null) || true
  local linked_branch
  linked_branch=$(git -C "$linked_wt" rev-parse --abbrev-ref HEAD 2>/dev/null) || true
  [[ -z "$linked_branch" ]] && linked_branch="${primary_branch:-master}"
  local tmp="$root/.grov-restore-tmp"
  git clone --local "$root/$BARE_REPO" "$tmp" -b "$linked_branch" || {
    echo "Error: Clone from bare failed." >&2
    exit 1
  }
  # Point clone's remotes at the real URLs, not the removed bare repo (clone only has origin â†’ bare path)
  local bare="$root/$BARE_REPO"
  while IFS= read -r name; do
    [[ -z "$name" ]] && continue
    url=$(git --git-dir="$bare" config --get "remote.$name.url" 2>/dev/null)
    [[ -z "$url" ]] && continue
    if [[ "$name" == "origin" ]]; then
      git -C "$tmp" remote set-url origin "$url"
    else
      git -C "$tmp" remote add "$name" "$url" 2>/dev/null || git -C "$tmp" remote set-url "$name" "$url"
      git --git-dir="$bare" config --get-all "remote.$name.fetch" 2>/dev/null | while IFS= read -r refspec; do
        [[ -n "$refspec" ]] && git -C "$tmp" config --add "remote.$name.fetch" "$refspec"
      done
    fi
  done < <(git --git-dir="$bare" remote 2>/dev/null)
  # Leave root so rm can remove .grov, branches, workspace (rm may fail if cwd is inside them)
  cd /tmp 2>/dev/null || cd "$root/.." || true
  rm -rf "$root/.grov" "$root/$BRANCHES_DIR_NAME" "$root/$LINK_NAME" || {
    echo "Error: Failed to remove .grov, branches, or workspace." >&2
    rm -rf "$tmp"
    exit 1
  }
  # Clear any other root content so mv from tmp doesn't nest duplicates
  for f in "$root"/* "$root"/.[!.]* "$root"/..?*; do
    [[ -e "$f" && "$f" != "$tmp" ]] && rm -rf "$f"
  done
  mv "$tmp/.git" "$root/.git"
  (cd "$tmp" && shopt -s dotglob nullglob 2>/dev/null; for f in *; do
    [[ -z "$f" || "$f" == ".git" ]] && continue
    [[ -e "$f" ]] && mv "$f" "$root/$f"
  done)
  rm -rf "$tmp"
  echo "Restored to normal git repo (branch $linked_branch at root)."
}

# Main: init does not require grov root
cmd="${1:-}"
shift || true
if [[ "$cmd" == "init" ]]; then
  cmd_init
  exit 0
fi

_raw_root=$(find_dev_root) || {
  echo "Error: Cannot find grov root (no .grov in path and GROV_ROOT not set)." >&2
  exit 1
}
GROV_ROOT=$(cd "${_raw_root%%[[:space:]]*}" && pwd)

case "$cmd" in
  checkout)   cmd_checkout "$GROV_ROOT" "$@" ;;
  switch)     cmd_switch "$GROV_ROOT" "$@" ;;
  add)        cmd_add "$GROV_ROOT" "$@" ;;
  status)     cmd_status "$GROV_ROOT" "$@" ;;
  remove)     cmd_remove "$GROV_ROOT" "$@" ;;
  root)       cmd_root "$GROV_ROOT" ;;
  branch)     cmd_branch "$GROV_ROOT" ;;
  branches)   cmd_branches "$GROV_ROOT" ;;
  path)       cmd_path "$GROV_ROOT" "$@" ;;
  restore)    cmd_restore "$GROV_ROOT" ;;
  scripts)    cmd_scripts "$GROV_ROOT" ;;
  "")
    usage
    ;;
  *)
    script_path="$GROV_ROOT/.grov/scripts/$cmd"
    if [[ -x "$script_path" && -f "$script_path" ]]; then
      export GROV_ROOT
      exec "$script_path" "$@"
    fi
    if [[ -f "$script_path" ]]; then
      echo "Script exists but is not executable: $script_path" >&2
      echo -n "Make it executable? [y/N] " >&2
      read -r ans
      if [[ "$ans" == [yY]* ]]; then
        chmod +x "$script_path"
        export GROV_ROOT
        exec "$script_path" "$@"
      fi
      exit 1
    fi
    echo "Unknown command: $cmd" >&2
    usage
    ;;
esac
