#!/usr/bin/env bash
# Grov CLI: worktrees, workspace symlink, build, and .dev/scripts.
#
# Install: run ./install from this repo (or ln -sf path/to/grov/grov ~/bin/grov).
# Usage: grov <command> [args...]
#   init                    convert current git repo to dev layout (bare at .dev/repo.git)
#   checkout [-b] <branch>  ensure worktree exists, point workspace at it; runs build
#   build [branch]          composer install, do_release.py, touch last_commit in worktree
#   status                  list worktrees and linked branch with git state
#   remove <branch>         remove a worktree
#   path                    print active workspace path
#   <script>                run .dev/scripts/<script> if present

set -e
LINK_NAME="workspace"
BRANCHES_DIR_NAME="branches"
MAIN_WORKTREE="master"
BARE_REPO=".dev/repo.git"

find_dev_root() {
  local d="$PWD"
  while [[ -n "$d" && "$d" != "/" ]]; do
    [[ -e "$d/.dev" ]] && echo "$d" && return 0
    d="${d%/*}"
  done
  [[ -n "$GROV_ROOT" && -e "$GROV_ROOT/.dev" ]] && echo "$GROV_ROOT" && return 0
  local script_path
  script_path=$(readlink -f "$0" 2>/dev/null || true)
  if [[ -n "$script_path" ]]; then
    d=$(dirname "$script_path")
    d=$(dirname "$d")
    [[ -e "$d/.dev" ]] && echo "$d" && return 0
  fi
  return 1
}

ensure_workspace() {
  local root=$1
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  if [[ -L "$link_path" ]]; then return 0; fi
  local branches_dir="$root/$BRANCHES_DIR_NAME"
  [[ ! -d "$branches_dir" ]] && return 1
  local first
  first=$(ls -1d "$branches_dir"/*/ 2>/dev/null | head -1)
  [[ -z "$first" ]] && return 1
  ln -sfn "$BRANCHES_DIR_NAME/$(basename "$first")" "$link_path"
}

get_linked_branch() {
  local root=$1
  ensure_workspace "$root" || true
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  if [[ ! -L "$link_path" ]]; then echo ""; return 1; fi
  local target
  target=$(readlink -f "$link_path")
  [[ -z "$target" ]] && echo "" && return 1
  basename "$target"
}

get_current_branch_from_cwd() {
  local root=$1
  local branches="$root/$BRANCHES_DIR_NAME"
  if [[ "$PWD" != "$branches"/* ]]; then
    echo ""; return 1
  fi
  local rest="${PWD#$branches/}"
  echo "${rest%%/*}"
}

get_worktree_path() {
  echo "$1/$BRANCHES_DIR_NAME/$2"
}

list_branch_dirs() {
  local root=$1
  local dir="$root/$BRANCHES_DIR_NAME"
  [[ ! -d "$dir" ]] && return 0
  local d
  for d in "$dir"/*/; do
    [[ -d "$d" ]] && basename "$d"
  done | sort
}

usage() {
  echo "Usage: grov <init|checkout|build|status|remove|path|restore> [args...]"
  echo "  init                    convert current git repo to grov layout"
  echo "  restore                 convert grov project back to normal git repo (linked branch at root)"
  echo "  checkout [-b] <branch>  ensure worktree exists, point workspace at it; runs build"
  echo "  build [branch]          composer install, do_release.py, touch last_commit in worktree"
  echo "  status                  list worktrees and linked branch with git state"
  echo "  remove <branch>         remove a worktree"
  echo "  path                    print active workspace path"
  echo "  <name>                  run .dev/scripts/<name> if present"
  exit 1
}

has_bare() { [[ -d "$1/$BARE_REPO" ]]; }

cmd_init() {
  local root
  root=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo "Error: Not inside a git repository. Run grov init from a repo root." >&2
    exit 1
  }
  cd "$root" || exit 1
  if [[ -e "$root/.dev" ]]; then
    echo "Error: Already a grov project (.dev exists)." >&2
    exit 1
  fi
  local branch
  branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || branch="rescue"
  [[ "$branch" == "HEAD" || -z "$branch" ]] && branch="rescue"
  local branch_dir="${branch//[^a-zA-Z0-9._-]/_}"
  mkdir -p .dev/scripts
  git init --bare "$BARE_REPO"
  (cd "$root" && git remote add _dev_bare "$(pwd)/$BARE_REPO" && git push _dev_bare --all && git push _dev_bare --tags 2>/dev/null; git remote remove _dev_bare 2>/dev/null)
  # Copy remotes from original repo into bare so fetch/push still work
  while IFS= read -r name; do
    [[ -z "$name" ]] && continue
    url=$(git -C "$root" config --get "remote.$name.url" 2>/dev/null)
    [[ -z "$url" ]] && continue
    git --git-dir="$root/$BARE_REPO" remote add "$name" "$url" 2>/dev/null || true
    git -C "$root" config --get-all "remote.$name.fetch" 2>/dev/null | while IFS= read -r refspec; do
      [[ -n "$refspec" ]] && git --git-dir="$root/$BARE_REPO" config --add "remote.$name.fetch" "$refspec"
    done
  done < <(git -C "$root" remote 2>/dev/null)
  mkdir -p "$BRANCHES_DIR_NAME"
  git --git-dir="$root/$BARE_REPO" worktree add "$BRANCHES_DIR_NAME/$branch_dir" "$branch" 2>/dev/null || \
    git --git-dir="$root/$BARE_REPO" worktree add "$BRANCHES_DIR_NAME/$branch_dir" HEAD
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  ln -sfn "$BRANCHES_DIR_NAME/$branch_dir" "$link_path"
  mkdir -p .dev/old-checkout
  (cd "$root" && git ls-files --others --exclude-standard) | while IFS= read -r f; do
    [[ -n "$f" && -e "$root/$f" ]] || continue
    mkdir -p "$root/.dev/old-checkout/$(dirname "$f")"
    mv "$root/$f" "$root/.dev/old-checkout/$f"
  done
  find "$root" -mindepth 1 -maxdepth 1 ! -name .dev ! -name "$BRANCHES_DIR_NAME" ! -name "$LINK_NAME" ! -name .git -exec rm -rf {} +
  rm -rf "$root/.git"
  echo "Untracked files from previous working tree. Refs in .dev/repo.git; worktree at branches/$branch_dir" > "$root/.dev/old-checkout/README.txt"
  echo "Initialized. workspace -> branches/$branch_dir. Untracked files in .dev/old-checkout."
}

cmd_path() {
  local root=$1
  ensure_workspace "$root" || { echo "Error: No workspace (no branches?)." >&2; exit 1; }
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  readlink -f "$link_path"
}

cmd_checkout() {
  local root=$1
  shift
  local create_branch=false
  if [[ "$1" == "-b" ]]; then create_branch=true; shift; fi
  local branch="$1"
  [[ -z "$branch" ]] && echo "Usage: grov checkout [-b] <branch>" >&2 && exit 1
  local wt_path
  wt_path=$(cd "$root" && pwd)/$BRANCHES_DIR_NAME/$branch
  local bare="$root/$BARE_REPO"
  if has_bare "$root"; then
    if [[ ! -d "$wt_path" ]]; then
      if [[ "$create_branch" == true ]]; then
        local src
        src=$(get_linked_branch "$root")
        [[ -z "$src" ]] && src="HEAD"
        git --git-dir="$bare" worktree add -b "$branch" "$wt_path" "$src"
        echo "Created branch '$branch' and worktree at $wt_path"
      else
        if ! git --git-dir="$bare" rev-parse --verify "$branch" &>/dev/null; then
          echo "Error: Branch '$branch' does not exist. Use: grov checkout -b <branch>" >&2
          exit 1
        fi
        git --git-dir="$bare" worktree add "$wt_path" "$branch"
        echo "Created worktree at $wt_path"
      fi
    fi
  else
    local repo="$root/$BRANCHES_DIR_NAME/$MAIN_WORKTREE"
    if [[ ! -d "$repo/.git" ]]; then
      echo "Error: No .dev/repo.git and no main worktree at $repo. Run grov init first." >&2
      exit 1
    fi
    if [[ -d "$wt_path" ]]; then
      :
    elif [[ "$create_branch" == true ]]; then
      local src
      src=$(get_linked_branch "$root")
      [[ -z "$src" ]] && echo "Error: workspace not linked; cannot use -b." >&2 && exit 1
      git -C "$repo" worktree add -b "$branch" "$wt_path" "$src"
      echo "Created branch '$branch' from '$src' and worktree at $wt_path"
    else
      if ! git -C "$repo" rev-parse --verify "$branch" &>/dev/null; then
        echo "Error: Branch '$branch' does not exist. Use: grov checkout -b <branch>" >&2
        exit 1
      fi
      git -C "$repo" worktree add "$wt_path" "$branch"
      echo "Created worktree at $wt_path"
    fi
  fi
  ensure_workspace "$root" || true
  local link_path
  link_path=$(cd "$root" && pwd)/$LINK_NAME
  ln -sfn "$BRANCHES_DIR_NAME/$branch" "$link_path"
  echo "Running build in $wt_path..."
  cmd_build "$root" "$branch"
}

cmd_build() {
  local root=$1
  local branch="${2:-}"
  if [[ -z "$branch" ]]; then
    branch=$(get_current_branch_from_cwd "$root")
    if [[ -z "$branch" ]]; then
      branch=$(get_linked_branch "$root")
      if [[ -z "$branch" ]]; then
        echo "Error: Not inside a branch folder and workspace not linked. Use: grov build <branch>" >&2
        exit 1
      fi
    fi
  fi

  local wt_path
  wt_path=$(get_worktree_path "$root" "$branch")
  wt_path=$(readlink -f "$wt_path" 2>/dev/null || true)
  [[ -z "$wt_path" || ! -d "$wt_path" ]] && wt_path="$root/$BRANCHES_DIR_NAME/$branch"

  if [[ ! -d "$wt_path" ]]; then
    echo "Error: Worktree does not exist: $wt_path" >&2
    exit 1
  fi
  if [[ -f "$wt_path/composer.json" && -f "$wt_path/do_release.py" ]]; then
    echo "Building branch: $branch ( $wt_path )"
    ( cd "$wt_path" && composer install && python3 do_release.py && touch last_commit && echo "Build complete." )
  else
    echo "Skipping build (no composer.json or do_release.py in $wt_path)."
  fi
}

cmd_remove() {
  local root=$1
  shift
  local branch="$1"
  [[ -z "$branch" ]] && echo "Usage: grov remove <branch>" >&2 && exit 1
  local wt_path
  wt_path=$(cd "$root" && pwd)/$BRANCHES_DIR_NAME/$branch
  if [[ ! -d "$wt_path" ]]; then
    echo "Error: No worktree at $wt_path" >&2
    exit 1
  fi
  if has_bare "$root"; then
    git --git-dir="$root/$BARE_REPO" worktree remove "$wt_path"
  else
    if [[ "$branch" == "$MAIN_WORKTREE" ]]; then
      echo "Error: Cannot remove the main worktree (master)." >&2
      exit 1
    fi
    git -C "$root/$BRANCHES_DIR_NAME/$MAIN_WORKTREE" worktree remove "$wt_path"
  fi
  echo "Removed worktree: $branch"
}

cmd_status() {
  local root=$1
  ensure_workspace "$root" || true
  local link_path="$root/$LINK_NAME"
  local linked=""
  if [[ -L "$link_path" ]]; then
    linked=$(basename "$(readlink "$link_path")")
  fi
  echo "Linked: ${linked:-none}"
  echo ""

  local branch
  while IFS= read -r branch; do
    [[ -z "$branch" ]] && continue
    local wt_path
    wt_path=$(get_worktree_path "$root" "$branch")
    [[ ! -d "$wt_path" ]] && continue

    local marker=""
    [[ "$branch" == "$linked" ]] && marker=" (linked)"

    local state=""
    if git -C "$wt_path" rev-parse --is-inside-work-tree &>/dev/null; then
      if [[ -n $(git -C "$wt_path" status -s 2>/dev/null) ]]; then
        state="uncommitted"
      else
        local ahead behind
        ahead=$(git -C "$wt_path" rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        behind=$(git -C "$wt_path" rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
        if [[ "$ahead" != "0" || "$behind" != "0" ]]; then
          state="ahead $ahead, behind $behind"
        else
          state="clean"
        fi
      fi
    else
      state="?"
    fi
    echo "  $branch$marker  $state"
  done < <(list_branch_dirs "$root")
}

cmd_restore() {
  local root=$1
  if [[ ! -d "$root/$BARE_REPO" ]]; then
    echo "Error: Not a grov project (no $BARE_REPO)." >&2
    exit 1
  fi
  ensure_workspace "$root" || { echo "Error: No workspace linked." >&2; exit 1; }
  local linked_dir
  linked_dir=$(get_linked_branch "$root")
  [[ -z "$linked_dir" ]] && { echo "Error: Could not get linked branch." >&2; exit 1; }
  local linked_wt="$root/$BRANCHES_DIR_NAME/$linked_dir"
  [[ ! -d "$linked_wt" ]] && { echo "Error: Worktree $linked_wt not found." >&2; exit 1; }
  local linked_branch
  linked_branch=$(git -C "$linked_wt" rev-parse --abbrev-ref HEAD 2>/dev/null) || linked_branch="$MAIN_WORKTREE"
  local tmp="$root/.grov-restore-tmp"
  git clone --local "$root/$BARE_REPO" "$tmp" -b "$linked_branch" || {
    echo "Error: Clone from bare failed." >&2
    exit 1
  }
  rm -rf "$root/.dev" "$root/$BRANCHES_DIR_NAME" "$root/$LINK_NAME"
  mv "$tmp/.git" "$root/.git"
  (cd "$tmp" && shopt -s dotglob nullglob 2>/dev/null; for f in *; do [[ -n "$f" && "$f" != ".git" && -e "$f" ]] && mv "$f" "$root/$f"; done)
  rm -rf "$tmp"
  echo "Restored to normal git repo (branch $linked_branch at root)."
}

# Main: init does not require grov root
cmd="${1:-}"
shift || true
if [[ "$cmd" == "init" ]]; then
  cmd_init
  exit 0
fi

_raw_root=$(find_dev_root) || {
  echo "Error: Cannot find grov root (no .dev in path and GROV_ROOT not set)." >&2
  exit 1
}
GROV_ROOT=$(cd "${_raw_root%%[[:space:]]*}" && pwd)

case "$cmd" in
  checkout)  cmd_checkout "$GROV_ROOT" "$@" ;;
  build)     cmd_build "$GROV_ROOT" "$@" ;;
  status)    cmd_status "$GROV_ROOT" "$@" ;;
  remove)    cmd_remove "$GROV_ROOT" "$@" ;;
  path)      cmd_path "$GROV_ROOT" ;;
  restore)   cmd_restore "$GROV_ROOT" ;;
  "")
    usage
    ;;
  *)
    script_path="$GROV_ROOT/.dev/scripts/$cmd"
    if [[ -x "$script_path" && -f "$script_path" ]]; then
      export GROV_ROOT
      exec "$script_path" "$@"
    fi
    echo "Unknown command: $cmd" >&2
    usage
    ;;
esac
